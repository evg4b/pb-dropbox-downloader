package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i pb-dropbox-downloader/infrastructure.Dropbox -o ./mocks\dropboxmock.go -n DropboxMock

import (
	"io"
	mm_infrastructure "pb-dropbox-downloader/infrastructure"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DropboxMock implements infrastructure.Dropbox
type DropboxMock struct {
	t minimock.Tester

	funcAccountDisplayName          func() (s1 string)
	inspectFuncAccountDisplayName   func()
	afterAccountDisplayNameCounter  uint64
	beforeAccountDisplayNameCounter uint64
	AccountDisplayNameMock          mDropboxMockAccountDisplayName

	funcAccountEmail          func() (s1 string)
	inspectFuncAccountEmail   func()
	afterAccountEmailCounter  uint64
	beforeAccountEmailCounter uint64
	AccountEmailMock          mDropboxMockAccountEmail

	funcDownloadFile          func(s1 string) (r1 io.ReadCloser, err error)
	inspectFuncDownloadFile   func(s1 string)
	afterDownloadFileCounter  uint64
	beforeDownloadFileCounter uint64
	DownloadFileMock          mDropboxMockDownloadFile

	funcGetFiles          func() (ra1 []mm_infrastructure.RemoteFile, err error)
	inspectFuncGetFiles   func()
	afterGetFilesCounter  uint64
	beforeGetFilesCounter uint64
	GetFilesMock          mDropboxMockGetFiles
}

// NewDropboxMock returns a mock for infrastructure.Dropbox
func NewDropboxMock(t minimock.Tester) *DropboxMock {
	m := &DropboxMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AccountDisplayNameMock = mDropboxMockAccountDisplayName{mock: m}

	m.AccountEmailMock = mDropboxMockAccountEmail{mock: m}

	m.DownloadFileMock = mDropboxMockDownloadFile{mock: m}
	m.DownloadFileMock.callArgs = []*DropboxMockDownloadFileParams{}

	m.GetFilesMock = mDropboxMockGetFiles{mock: m}

	return m
}

type mDropboxMockAccountDisplayName struct {
	mock               *DropboxMock
	defaultExpectation *DropboxMockAccountDisplayNameExpectation
	expectations       []*DropboxMockAccountDisplayNameExpectation
}

// DropboxMockAccountDisplayNameExpectation specifies expectation struct of the Dropbox.AccountDisplayName
type DropboxMockAccountDisplayNameExpectation struct {
	mock *DropboxMock

	results *DropboxMockAccountDisplayNameResults
	Counter uint64
}

// DropboxMockAccountDisplayNameResults contains results of the Dropbox.AccountDisplayName
type DropboxMockAccountDisplayNameResults struct {
	s1 string
}

// Expect sets up expected params for Dropbox.AccountDisplayName
func (mmAccountDisplayName *mDropboxMockAccountDisplayName) Expect() *mDropboxMockAccountDisplayName {
	if mmAccountDisplayName.mock.funcAccountDisplayName != nil {
		mmAccountDisplayName.mock.t.Fatalf("DropboxMock.AccountDisplayName mock is already set by Set")
	}

	if mmAccountDisplayName.defaultExpectation == nil {
		mmAccountDisplayName.defaultExpectation = &DropboxMockAccountDisplayNameExpectation{}
	}

	return mmAccountDisplayName
}

// Inspect accepts an inspector function that has same arguments as the Dropbox.AccountDisplayName
func (mmAccountDisplayName *mDropboxMockAccountDisplayName) Inspect(f func()) *mDropboxMockAccountDisplayName {
	if mmAccountDisplayName.mock.inspectFuncAccountDisplayName != nil {
		mmAccountDisplayName.mock.t.Fatalf("Inspect function is already set for DropboxMock.AccountDisplayName")
	}

	mmAccountDisplayName.mock.inspectFuncAccountDisplayName = f

	return mmAccountDisplayName
}

// Return sets up results that will be returned by Dropbox.AccountDisplayName
func (mmAccountDisplayName *mDropboxMockAccountDisplayName) Return(s1 string) *DropboxMock {
	if mmAccountDisplayName.mock.funcAccountDisplayName != nil {
		mmAccountDisplayName.mock.t.Fatalf("DropboxMock.AccountDisplayName mock is already set by Set")
	}

	if mmAccountDisplayName.defaultExpectation == nil {
		mmAccountDisplayName.defaultExpectation = &DropboxMockAccountDisplayNameExpectation{mock: mmAccountDisplayName.mock}
	}
	mmAccountDisplayName.defaultExpectation.results = &DropboxMockAccountDisplayNameResults{s1}
	return mmAccountDisplayName.mock
}

//Set uses given function f to mock the Dropbox.AccountDisplayName method
func (mmAccountDisplayName *mDropboxMockAccountDisplayName) Set(f func() (s1 string)) *DropboxMock {
	if mmAccountDisplayName.defaultExpectation != nil {
		mmAccountDisplayName.mock.t.Fatalf("Default expectation is already set for the Dropbox.AccountDisplayName method")
	}

	if len(mmAccountDisplayName.expectations) > 0 {
		mmAccountDisplayName.mock.t.Fatalf("Some expectations are already set for the Dropbox.AccountDisplayName method")
	}

	mmAccountDisplayName.mock.funcAccountDisplayName = f
	return mmAccountDisplayName.mock
}

// AccountDisplayName implements infrastructure.Dropbox
func (mmAccountDisplayName *DropboxMock) AccountDisplayName() (s1 string) {
	mm_atomic.AddUint64(&mmAccountDisplayName.beforeAccountDisplayNameCounter, 1)
	defer mm_atomic.AddUint64(&mmAccountDisplayName.afterAccountDisplayNameCounter, 1)

	if mmAccountDisplayName.inspectFuncAccountDisplayName != nil {
		mmAccountDisplayName.inspectFuncAccountDisplayName()
	}

	if mmAccountDisplayName.AccountDisplayNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccountDisplayName.AccountDisplayNameMock.defaultExpectation.Counter, 1)

		mm_results := mmAccountDisplayName.AccountDisplayNameMock.defaultExpectation.results
		if mm_results == nil {
			mmAccountDisplayName.t.Fatal("No results are set for the DropboxMock.AccountDisplayName")
		}
		return (*mm_results).s1
	}
	if mmAccountDisplayName.funcAccountDisplayName != nil {
		return mmAccountDisplayName.funcAccountDisplayName()
	}
	mmAccountDisplayName.t.Fatalf("Unexpected call to DropboxMock.AccountDisplayName.")
	return
}

// AccountDisplayNameAfterCounter returns a count of finished DropboxMock.AccountDisplayName invocations
func (mmAccountDisplayName *DropboxMock) AccountDisplayNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccountDisplayName.afterAccountDisplayNameCounter)
}

// AccountDisplayNameBeforeCounter returns a count of DropboxMock.AccountDisplayName invocations
func (mmAccountDisplayName *DropboxMock) AccountDisplayNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccountDisplayName.beforeAccountDisplayNameCounter)
}

// MinimockAccountDisplayNameDone returns true if the count of the AccountDisplayName invocations corresponds
// the number of defined expectations
func (m *DropboxMock) MinimockAccountDisplayNameDone() bool {
	for _, e := range m.AccountDisplayNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccountDisplayNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccountDisplayNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccountDisplayName != nil && mm_atomic.LoadUint64(&m.afterAccountDisplayNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockAccountDisplayNameInspect logs each unmet expectation
func (m *DropboxMock) MinimockAccountDisplayNameInspect() {
	for _, e := range m.AccountDisplayNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DropboxMock.AccountDisplayName")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccountDisplayNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccountDisplayNameCounter) < 1 {
		m.t.Error("Expected call to DropboxMock.AccountDisplayName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccountDisplayName != nil && mm_atomic.LoadUint64(&m.afterAccountDisplayNameCounter) < 1 {
		m.t.Error("Expected call to DropboxMock.AccountDisplayName")
	}
}

type mDropboxMockAccountEmail struct {
	mock               *DropboxMock
	defaultExpectation *DropboxMockAccountEmailExpectation
	expectations       []*DropboxMockAccountEmailExpectation
}

// DropboxMockAccountEmailExpectation specifies expectation struct of the Dropbox.AccountEmail
type DropboxMockAccountEmailExpectation struct {
	mock *DropboxMock

	results *DropboxMockAccountEmailResults
	Counter uint64
}

// DropboxMockAccountEmailResults contains results of the Dropbox.AccountEmail
type DropboxMockAccountEmailResults struct {
	s1 string
}

// Expect sets up expected params for Dropbox.AccountEmail
func (mmAccountEmail *mDropboxMockAccountEmail) Expect() *mDropboxMockAccountEmail {
	if mmAccountEmail.mock.funcAccountEmail != nil {
		mmAccountEmail.mock.t.Fatalf("DropboxMock.AccountEmail mock is already set by Set")
	}

	if mmAccountEmail.defaultExpectation == nil {
		mmAccountEmail.defaultExpectation = &DropboxMockAccountEmailExpectation{}
	}

	return mmAccountEmail
}

// Inspect accepts an inspector function that has same arguments as the Dropbox.AccountEmail
func (mmAccountEmail *mDropboxMockAccountEmail) Inspect(f func()) *mDropboxMockAccountEmail {
	if mmAccountEmail.mock.inspectFuncAccountEmail != nil {
		mmAccountEmail.mock.t.Fatalf("Inspect function is already set for DropboxMock.AccountEmail")
	}

	mmAccountEmail.mock.inspectFuncAccountEmail = f

	return mmAccountEmail
}

// Return sets up results that will be returned by Dropbox.AccountEmail
func (mmAccountEmail *mDropboxMockAccountEmail) Return(s1 string) *DropboxMock {
	if mmAccountEmail.mock.funcAccountEmail != nil {
		mmAccountEmail.mock.t.Fatalf("DropboxMock.AccountEmail mock is already set by Set")
	}

	if mmAccountEmail.defaultExpectation == nil {
		mmAccountEmail.defaultExpectation = &DropboxMockAccountEmailExpectation{mock: mmAccountEmail.mock}
	}
	mmAccountEmail.defaultExpectation.results = &DropboxMockAccountEmailResults{s1}
	return mmAccountEmail.mock
}

//Set uses given function f to mock the Dropbox.AccountEmail method
func (mmAccountEmail *mDropboxMockAccountEmail) Set(f func() (s1 string)) *DropboxMock {
	if mmAccountEmail.defaultExpectation != nil {
		mmAccountEmail.mock.t.Fatalf("Default expectation is already set for the Dropbox.AccountEmail method")
	}

	if len(mmAccountEmail.expectations) > 0 {
		mmAccountEmail.mock.t.Fatalf("Some expectations are already set for the Dropbox.AccountEmail method")
	}

	mmAccountEmail.mock.funcAccountEmail = f
	return mmAccountEmail.mock
}

// AccountEmail implements infrastructure.Dropbox
func (mmAccountEmail *DropboxMock) AccountEmail() (s1 string) {
	mm_atomic.AddUint64(&mmAccountEmail.beforeAccountEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmAccountEmail.afterAccountEmailCounter, 1)

	if mmAccountEmail.inspectFuncAccountEmail != nil {
		mmAccountEmail.inspectFuncAccountEmail()
	}

	if mmAccountEmail.AccountEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccountEmail.AccountEmailMock.defaultExpectation.Counter, 1)

		mm_results := mmAccountEmail.AccountEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmAccountEmail.t.Fatal("No results are set for the DropboxMock.AccountEmail")
		}
		return (*mm_results).s1
	}
	if mmAccountEmail.funcAccountEmail != nil {
		return mmAccountEmail.funcAccountEmail()
	}
	mmAccountEmail.t.Fatalf("Unexpected call to DropboxMock.AccountEmail.")
	return
}

// AccountEmailAfterCounter returns a count of finished DropboxMock.AccountEmail invocations
func (mmAccountEmail *DropboxMock) AccountEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccountEmail.afterAccountEmailCounter)
}

// AccountEmailBeforeCounter returns a count of DropboxMock.AccountEmail invocations
func (mmAccountEmail *DropboxMock) AccountEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccountEmail.beforeAccountEmailCounter)
}

// MinimockAccountEmailDone returns true if the count of the AccountEmail invocations corresponds
// the number of defined expectations
func (m *DropboxMock) MinimockAccountEmailDone() bool {
	for _, e := range m.AccountEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccountEmailMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccountEmailCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccountEmail != nil && mm_atomic.LoadUint64(&m.afterAccountEmailCounter) < 1 {
		return false
	}
	return true
}

// MinimockAccountEmailInspect logs each unmet expectation
func (m *DropboxMock) MinimockAccountEmailInspect() {
	for _, e := range m.AccountEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DropboxMock.AccountEmail")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccountEmailMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccountEmailCounter) < 1 {
		m.t.Error("Expected call to DropboxMock.AccountEmail")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccountEmail != nil && mm_atomic.LoadUint64(&m.afterAccountEmailCounter) < 1 {
		m.t.Error("Expected call to DropboxMock.AccountEmail")
	}
}

type mDropboxMockDownloadFile struct {
	mock               *DropboxMock
	defaultExpectation *DropboxMockDownloadFileExpectation
	expectations       []*DropboxMockDownloadFileExpectation

	callArgs []*DropboxMockDownloadFileParams
	mutex    sync.RWMutex
}

// DropboxMockDownloadFileExpectation specifies expectation struct of the Dropbox.DownloadFile
type DropboxMockDownloadFileExpectation struct {
	mock    *DropboxMock
	params  *DropboxMockDownloadFileParams
	results *DropboxMockDownloadFileResults
	Counter uint64
}

// DropboxMockDownloadFileParams contains parameters of the Dropbox.DownloadFile
type DropboxMockDownloadFileParams struct {
	s1 string
}

// DropboxMockDownloadFileResults contains results of the Dropbox.DownloadFile
type DropboxMockDownloadFileResults struct {
	r1  io.ReadCloser
	err error
}

// Expect sets up expected params for Dropbox.DownloadFile
func (mmDownloadFile *mDropboxMockDownloadFile) Expect(s1 string) *mDropboxMockDownloadFile {
	if mmDownloadFile.mock.funcDownloadFile != nil {
		mmDownloadFile.mock.t.Fatalf("DropboxMock.DownloadFile mock is already set by Set")
	}

	if mmDownloadFile.defaultExpectation == nil {
		mmDownloadFile.defaultExpectation = &DropboxMockDownloadFileExpectation{}
	}

	mmDownloadFile.defaultExpectation.params = &DropboxMockDownloadFileParams{s1}
	for _, e := range mmDownloadFile.expectations {
		if minimock.Equal(e.params, mmDownloadFile.defaultExpectation.params) {
			mmDownloadFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDownloadFile.defaultExpectation.params)
		}
	}

	return mmDownloadFile
}

// Inspect accepts an inspector function that has same arguments as the Dropbox.DownloadFile
func (mmDownloadFile *mDropboxMockDownloadFile) Inspect(f func(s1 string)) *mDropboxMockDownloadFile {
	if mmDownloadFile.mock.inspectFuncDownloadFile != nil {
		mmDownloadFile.mock.t.Fatalf("Inspect function is already set for DropboxMock.DownloadFile")
	}

	mmDownloadFile.mock.inspectFuncDownloadFile = f

	return mmDownloadFile
}

// Return sets up results that will be returned by Dropbox.DownloadFile
func (mmDownloadFile *mDropboxMockDownloadFile) Return(r1 io.ReadCloser, err error) *DropboxMock {
	if mmDownloadFile.mock.funcDownloadFile != nil {
		mmDownloadFile.mock.t.Fatalf("DropboxMock.DownloadFile mock is already set by Set")
	}

	if mmDownloadFile.defaultExpectation == nil {
		mmDownloadFile.defaultExpectation = &DropboxMockDownloadFileExpectation{mock: mmDownloadFile.mock}
	}
	mmDownloadFile.defaultExpectation.results = &DropboxMockDownloadFileResults{r1, err}
	return mmDownloadFile.mock
}

//Set uses given function f to mock the Dropbox.DownloadFile method
func (mmDownloadFile *mDropboxMockDownloadFile) Set(f func(s1 string) (r1 io.ReadCloser, err error)) *DropboxMock {
	if mmDownloadFile.defaultExpectation != nil {
		mmDownloadFile.mock.t.Fatalf("Default expectation is already set for the Dropbox.DownloadFile method")
	}

	if len(mmDownloadFile.expectations) > 0 {
		mmDownloadFile.mock.t.Fatalf("Some expectations are already set for the Dropbox.DownloadFile method")
	}

	mmDownloadFile.mock.funcDownloadFile = f
	return mmDownloadFile.mock
}

// When sets expectation for the Dropbox.DownloadFile which will trigger the result defined by the following
// Then helper
func (mmDownloadFile *mDropboxMockDownloadFile) When(s1 string) *DropboxMockDownloadFileExpectation {
	if mmDownloadFile.mock.funcDownloadFile != nil {
		mmDownloadFile.mock.t.Fatalf("DropboxMock.DownloadFile mock is already set by Set")
	}

	expectation := &DropboxMockDownloadFileExpectation{
		mock:   mmDownloadFile.mock,
		params: &DropboxMockDownloadFileParams{s1},
	}
	mmDownloadFile.expectations = append(mmDownloadFile.expectations, expectation)
	return expectation
}

// Then sets up Dropbox.DownloadFile return parameters for the expectation previously defined by the When method
func (e *DropboxMockDownloadFileExpectation) Then(r1 io.ReadCloser, err error) *DropboxMock {
	e.results = &DropboxMockDownloadFileResults{r1, err}
	return e.mock
}

// DownloadFile implements infrastructure.Dropbox
func (mmDownloadFile *DropboxMock) DownloadFile(s1 string) (r1 io.ReadCloser, err error) {
	mm_atomic.AddUint64(&mmDownloadFile.beforeDownloadFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDownloadFile.afterDownloadFileCounter, 1)

	if mmDownloadFile.inspectFuncDownloadFile != nil {
		mmDownloadFile.inspectFuncDownloadFile(s1)
	}

	mm_params := &DropboxMockDownloadFileParams{s1}

	// Record call args
	mmDownloadFile.DownloadFileMock.mutex.Lock()
	mmDownloadFile.DownloadFileMock.callArgs = append(mmDownloadFile.DownloadFileMock.callArgs, mm_params)
	mmDownloadFile.DownloadFileMock.mutex.Unlock()

	for _, e := range mmDownloadFile.DownloadFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmDownloadFile.DownloadFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDownloadFile.DownloadFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDownloadFile.DownloadFileMock.defaultExpectation.params
		mm_got := DropboxMockDownloadFileParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDownloadFile.t.Errorf("DropboxMock.DownloadFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDownloadFile.DownloadFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDownloadFile.t.Fatal("No results are set for the DropboxMock.DownloadFile")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmDownloadFile.funcDownloadFile != nil {
		return mmDownloadFile.funcDownloadFile(s1)
	}
	mmDownloadFile.t.Fatalf("Unexpected call to DropboxMock.DownloadFile. %v", s1)
	return
}

// DownloadFileAfterCounter returns a count of finished DropboxMock.DownloadFile invocations
func (mmDownloadFile *DropboxMock) DownloadFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDownloadFile.afterDownloadFileCounter)
}

// DownloadFileBeforeCounter returns a count of DropboxMock.DownloadFile invocations
func (mmDownloadFile *DropboxMock) DownloadFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDownloadFile.beforeDownloadFileCounter)
}

// Calls returns a list of arguments used in each call to DropboxMock.DownloadFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDownloadFile *mDropboxMockDownloadFile) Calls() []*DropboxMockDownloadFileParams {
	mmDownloadFile.mutex.RLock()

	argCopy := make([]*DropboxMockDownloadFileParams, len(mmDownloadFile.callArgs))
	copy(argCopy, mmDownloadFile.callArgs)

	mmDownloadFile.mutex.RUnlock()

	return argCopy
}

// MinimockDownloadFileDone returns true if the count of the DownloadFile invocations corresponds
// the number of defined expectations
func (m *DropboxMock) MinimockDownloadFileDone() bool {
	for _, e := range m.DownloadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DownloadFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDownloadFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDownloadFile != nil && mm_atomic.LoadUint64(&m.afterDownloadFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockDownloadFileInspect logs each unmet expectation
func (m *DropboxMock) MinimockDownloadFileInspect() {
	for _, e := range m.DownloadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DropboxMock.DownloadFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DownloadFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDownloadFileCounter) < 1 {
		if m.DownloadFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DropboxMock.DownloadFile")
		} else {
			m.t.Errorf("Expected call to DropboxMock.DownloadFile with params: %#v", *m.DownloadFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDownloadFile != nil && mm_atomic.LoadUint64(&m.afterDownloadFileCounter) < 1 {
		m.t.Error("Expected call to DropboxMock.DownloadFile")
	}
}

type mDropboxMockGetFiles struct {
	mock               *DropboxMock
	defaultExpectation *DropboxMockGetFilesExpectation
	expectations       []*DropboxMockGetFilesExpectation
}

// DropboxMockGetFilesExpectation specifies expectation struct of the Dropbox.GetFiles
type DropboxMockGetFilesExpectation struct {
	mock *DropboxMock

	results *DropboxMockGetFilesResults
	Counter uint64
}

// DropboxMockGetFilesResults contains results of the Dropbox.GetFiles
type DropboxMockGetFilesResults struct {
	ra1 []mm_infrastructure.RemoteFile
	err error
}

// Expect sets up expected params for Dropbox.GetFiles
func (mmGetFiles *mDropboxMockGetFiles) Expect() *mDropboxMockGetFiles {
	if mmGetFiles.mock.funcGetFiles != nil {
		mmGetFiles.mock.t.Fatalf("DropboxMock.GetFiles mock is already set by Set")
	}

	if mmGetFiles.defaultExpectation == nil {
		mmGetFiles.defaultExpectation = &DropboxMockGetFilesExpectation{}
	}

	return mmGetFiles
}

// Inspect accepts an inspector function that has same arguments as the Dropbox.GetFiles
func (mmGetFiles *mDropboxMockGetFiles) Inspect(f func()) *mDropboxMockGetFiles {
	if mmGetFiles.mock.inspectFuncGetFiles != nil {
		mmGetFiles.mock.t.Fatalf("Inspect function is already set for DropboxMock.GetFiles")
	}

	mmGetFiles.mock.inspectFuncGetFiles = f

	return mmGetFiles
}

// Return sets up results that will be returned by Dropbox.GetFiles
func (mmGetFiles *mDropboxMockGetFiles) Return(ra1 []mm_infrastructure.RemoteFile, err error) *DropboxMock {
	if mmGetFiles.mock.funcGetFiles != nil {
		mmGetFiles.mock.t.Fatalf("DropboxMock.GetFiles mock is already set by Set")
	}

	if mmGetFiles.defaultExpectation == nil {
		mmGetFiles.defaultExpectation = &DropboxMockGetFilesExpectation{mock: mmGetFiles.mock}
	}
	mmGetFiles.defaultExpectation.results = &DropboxMockGetFilesResults{ra1, err}
	return mmGetFiles.mock
}

//Set uses given function f to mock the Dropbox.GetFiles method
func (mmGetFiles *mDropboxMockGetFiles) Set(f func() (ra1 []mm_infrastructure.RemoteFile, err error)) *DropboxMock {
	if mmGetFiles.defaultExpectation != nil {
		mmGetFiles.mock.t.Fatalf("Default expectation is already set for the Dropbox.GetFiles method")
	}

	if len(mmGetFiles.expectations) > 0 {
		mmGetFiles.mock.t.Fatalf("Some expectations are already set for the Dropbox.GetFiles method")
	}

	mmGetFiles.mock.funcGetFiles = f
	return mmGetFiles.mock
}

// GetFiles implements infrastructure.Dropbox
func (mmGetFiles *DropboxMock) GetFiles() (ra1 []mm_infrastructure.RemoteFile, err error) {
	mm_atomic.AddUint64(&mmGetFiles.beforeGetFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFiles.afterGetFilesCounter, 1)

	if mmGetFiles.inspectFuncGetFiles != nil {
		mmGetFiles.inspectFuncGetFiles()
	}

	if mmGetFiles.GetFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFiles.GetFilesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetFiles.GetFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFiles.t.Fatal("No results are set for the DropboxMock.GetFiles")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmGetFiles.funcGetFiles != nil {
		return mmGetFiles.funcGetFiles()
	}
	mmGetFiles.t.Fatalf("Unexpected call to DropboxMock.GetFiles.")
	return
}

// GetFilesAfterCounter returns a count of finished DropboxMock.GetFiles invocations
func (mmGetFiles *DropboxMock) GetFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFiles.afterGetFilesCounter)
}

// GetFilesBeforeCounter returns a count of DropboxMock.GetFiles invocations
func (mmGetFiles *DropboxMock) GetFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFiles.beforeGetFilesCounter)
}

// MinimockGetFilesDone returns true if the count of the GetFiles invocations corresponds
// the number of defined expectations
func (m *DropboxMock) MinimockGetFilesDone() bool {
	for _, e := range m.GetFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFiles != nil && mm_atomic.LoadUint64(&m.afterGetFilesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFilesInspect logs each unmet expectation
func (m *DropboxMock) MinimockGetFilesInspect() {
	for _, e := range m.GetFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DropboxMock.GetFiles")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesCounter) < 1 {
		m.t.Error("Expected call to DropboxMock.GetFiles")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFiles != nil && mm_atomic.LoadUint64(&m.afterGetFilesCounter) < 1 {
		m.t.Error("Expected call to DropboxMock.GetFiles")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DropboxMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAccountDisplayNameInspect()

		m.MinimockAccountEmailInspect()

		m.MinimockDownloadFileInspect()

		m.MinimockGetFilesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DropboxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DropboxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAccountDisplayNameDone() &&
		m.MinimockAccountEmailDone() &&
		m.MinimockDownloadFileDone() &&
		m.MinimockGetFilesDone()
}
