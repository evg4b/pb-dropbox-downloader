package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i pb-dropbox-downloader/infrastructure.FileSystem -o ./mocks\file_systemmock.go

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FileSystemMock implements infrastructure.FileSystem
type FileSystemMock struct {
	t minimock.Tester

	funcCopyDataToFile          func(s1 string, r1 io.Reader) (err error)
	inspectFuncCopyDataToFile   func(s1 string, r1 io.Reader)
	afterCopyDataToFileCounter  uint64
	beforeCopyDataToFileCounter uint64
	CopyDataToFileMock          mFileSystemMockCopyDataToFile

	funcDeleteFile          func(s1 string) (err error)
	inspectFuncDeleteFile   func(s1 string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mFileSystemMockDeleteFile

	funcGetFilesInFolder          func(s1 string) (sa1 []string)
	inspectFuncGetFilesInFolder   func(s1 string)
	afterGetFilesInFolderCounter  uint64
	beforeGetFilesInFolderCounter uint64
	GetFilesInFolderMock          mFileSystemMockGetFilesInFolder
}

// NewFileSystemMock returns a mock for infrastructure.FileSystem
func NewFileSystemMock(t minimock.Tester) *FileSystemMock {
	m := &FileSystemMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CopyDataToFileMock = mFileSystemMockCopyDataToFile{mock: m}
	m.CopyDataToFileMock.callArgs = []*FileSystemMockCopyDataToFileParams{}

	m.DeleteFileMock = mFileSystemMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*FileSystemMockDeleteFileParams{}

	m.GetFilesInFolderMock = mFileSystemMockGetFilesInFolder{mock: m}
	m.GetFilesInFolderMock.callArgs = []*FileSystemMockGetFilesInFolderParams{}

	return m
}

type mFileSystemMockCopyDataToFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockCopyDataToFileExpectation
	expectations       []*FileSystemMockCopyDataToFileExpectation

	callArgs []*FileSystemMockCopyDataToFileParams
	mutex    sync.RWMutex
}

// FileSystemMockCopyDataToFileExpectation specifies expectation struct of the FileSystem.CopyDataToFile
type FileSystemMockCopyDataToFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockCopyDataToFileParams
	results *FileSystemMockCopyDataToFileResults
	Counter uint64
}

// FileSystemMockCopyDataToFileParams contains parameters of the FileSystem.CopyDataToFile
type FileSystemMockCopyDataToFileParams struct {
	s1 string
	r1 io.Reader
}

// FileSystemMockCopyDataToFileResults contains results of the FileSystem.CopyDataToFile
type FileSystemMockCopyDataToFileResults struct {
	err error
}

// Expect sets up expected params for FileSystem.CopyDataToFile
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Expect(s1 string, r1 io.Reader) *mFileSystemMockCopyDataToFile {
	if mmCopyDataToFile.mock.funcCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("FileSystemMock.CopyDataToFile mock is already set by Set")
	}

	if mmCopyDataToFile.defaultExpectation == nil {
		mmCopyDataToFile.defaultExpectation = &FileSystemMockCopyDataToFileExpectation{}
	}

	mmCopyDataToFile.defaultExpectation.params = &FileSystemMockCopyDataToFileParams{s1, r1}
	for _, e := range mmCopyDataToFile.expectations {
		if minimock.Equal(e.params, mmCopyDataToFile.defaultExpectation.params) {
			mmCopyDataToFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyDataToFile.defaultExpectation.params)
		}
	}

	return mmCopyDataToFile
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.CopyDataToFile
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Inspect(f func(s1 string, r1 io.Reader)) *mFileSystemMockCopyDataToFile {
	if mmCopyDataToFile.mock.inspectFuncCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("Inspect function is already set for FileSystemMock.CopyDataToFile")
	}

	mmCopyDataToFile.mock.inspectFuncCopyDataToFile = f

	return mmCopyDataToFile
}

// Return sets up results that will be returned by FileSystem.CopyDataToFile
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Return(err error) *FileSystemMock {
	if mmCopyDataToFile.mock.funcCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("FileSystemMock.CopyDataToFile mock is already set by Set")
	}

	if mmCopyDataToFile.defaultExpectation == nil {
		mmCopyDataToFile.defaultExpectation = &FileSystemMockCopyDataToFileExpectation{mock: mmCopyDataToFile.mock}
	}
	mmCopyDataToFile.defaultExpectation.results = &FileSystemMockCopyDataToFileResults{err}
	return mmCopyDataToFile.mock
}

//Set uses given function f to mock the FileSystem.CopyDataToFile method
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Set(f func(s1 string, r1 io.Reader) (err error)) *FileSystemMock {
	if mmCopyDataToFile.defaultExpectation != nil {
		mmCopyDataToFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.CopyDataToFile method")
	}

	if len(mmCopyDataToFile.expectations) > 0 {
		mmCopyDataToFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.CopyDataToFile method")
	}

	mmCopyDataToFile.mock.funcCopyDataToFile = f
	return mmCopyDataToFile.mock
}

// When sets expectation for the FileSystem.CopyDataToFile which will trigger the result defined by the following
// Then helper
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) When(s1 string, r1 io.Reader) *FileSystemMockCopyDataToFileExpectation {
	if mmCopyDataToFile.mock.funcCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("FileSystemMock.CopyDataToFile mock is already set by Set")
	}

	expectation := &FileSystemMockCopyDataToFileExpectation{
		mock:   mmCopyDataToFile.mock,
		params: &FileSystemMockCopyDataToFileParams{s1, r1},
	}
	mmCopyDataToFile.expectations = append(mmCopyDataToFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.CopyDataToFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockCopyDataToFileExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockCopyDataToFileResults{err}
	return e.mock
}

// CopyDataToFile implements infrastructure.FileSystem
func (mmCopyDataToFile *FileSystemMock) CopyDataToFile(s1 string, r1 io.Reader) (err error) {
	mm_atomic.AddUint64(&mmCopyDataToFile.beforeCopyDataToFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyDataToFile.afterCopyDataToFileCounter, 1)

	if mmCopyDataToFile.inspectFuncCopyDataToFile != nil {
		mmCopyDataToFile.inspectFuncCopyDataToFile(s1, r1)
	}

	mm_params := &FileSystemMockCopyDataToFileParams{s1, r1}

	// Record call args
	mmCopyDataToFile.CopyDataToFileMock.mutex.Lock()
	mmCopyDataToFile.CopyDataToFileMock.callArgs = append(mmCopyDataToFile.CopyDataToFileMock.callArgs, mm_params)
	mmCopyDataToFile.CopyDataToFileMock.mutex.Unlock()

	for _, e := range mmCopyDataToFile.CopyDataToFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCopyDataToFile.CopyDataToFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyDataToFile.CopyDataToFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyDataToFile.CopyDataToFileMock.defaultExpectation.params
		mm_got := FileSystemMockCopyDataToFileParams{s1, r1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyDataToFile.t.Errorf("FileSystemMock.CopyDataToFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyDataToFile.CopyDataToFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyDataToFile.t.Fatal("No results are set for the FileSystemMock.CopyDataToFile")
		}
		return (*mm_results).err
	}
	if mmCopyDataToFile.funcCopyDataToFile != nil {
		return mmCopyDataToFile.funcCopyDataToFile(s1, r1)
	}
	mmCopyDataToFile.t.Fatalf("Unexpected call to FileSystemMock.CopyDataToFile. %v %v", s1, r1)
	return
}

// CopyDataToFileAfterCounter returns a count of finished FileSystemMock.CopyDataToFile invocations
func (mmCopyDataToFile *FileSystemMock) CopyDataToFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyDataToFile.afterCopyDataToFileCounter)
}

// CopyDataToFileBeforeCounter returns a count of FileSystemMock.CopyDataToFile invocations
func (mmCopyDataToFile *FileSystemMock) CopyDataToFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyDataToFile.beforeCopyDataToFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.CopyDataToFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Calls() []*FileSystemMockCopyDataToFileParams {
	mmCopyDataToFile.mutex.RLock()

	argCopy := make([]*FileSystemMockCopyDataToFileParams, len(mmCopyDataToFile.callArgs))
	copy(argCopy, mmCopyDataToFile.callArgs)

	mmCopyDataToFile.mutex.RUnlock()

	return argCopy
}

// MinimockCopyDataToFileDone returns true if the count of the CopyDataToFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockCopyDataToFileDone() bool {
	for _, e := range m.CopyDataToFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyDataToFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyDataToFile != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyDataToFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockCopyDataToFileInspect() {
	for _, e := range m.CopyDataToFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.CopyDataToFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyDataToFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		if m.CopyDataToFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.CopyDataToFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.CopyDataToFile with params: %#v", *m.CopyDataToFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyDataToFile != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.CopyDataToFile")
	}
}

type mFileSystemMockDeleteFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockDeleteFileExpectation
	expectations       []*FileSystemMockDeleteFileExpectation

	callArgs []*FileSystemMockDeleteFileParams
	mutex    sync.RWMutex
}

// FileSystemMockDeleteFileExpectation specifies expectation struct of the FileSystem.DeleteFile
type FileSystemMockDeleteFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockDeleteFileParams
	results *FileSystemMockDeleteFileResults
	Counter uint64
}

// FileSystemMockDeleteFileParams contains parameters of the FileSystem.DeleteFile
type FileSystemMockDeleteFileParams struct {
	s1 string
}

// FileSystemMockDeleteFileResults contains results of the FileSystem.DeleteFile
type FileSystemMockDeleteFileResults struct {
	err error
}

// Expect sets up expected params for FileSystem.DeleteFile
func (mmDeleteFile *mFileSystemMockDeleteFile) Expect(s1 string) *mFileSystemMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("FileSystemMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &FileSystemMockDeleteFileExpectation{}
	}

	mmDeleteFile.defaultExpectation.params = &FileSystemMockDeleteFileParams{s1}
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.DeleteFile
func (mmDeleteFile *mFileSystemMockDeleteFile) Inspect(f func(s1 string)) *mFileSystemMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for FileSystemMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by FileSystem.DeleteFile
func (mmDeleteFile *mFileSystemMockDeleteFile) Return(err error) *FileSystemMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("FileSystemMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &FileSystemMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &FileSystemMockDeleteFileResults{err}
	return mmDeleteFile.mock
}

//Set uses given function f to mock the FileSystem.DeleteFile method
func (mmDeleteFile *mFileSystemMockDeleteFile) Set(f func(s1 string) (err error)) *FileSystemMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	return mmDeleteFile.mock
}

// When sets expectation for the FileSystem.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mFileSystemMockDeleteFile) When(s1 string) *FileSystemMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("FileSystemMock.DeleteFile mock is already set by Set")
	}

	expectation := &FileSystemMockDeleteFileExpectation{
		mock:   mmDeleteFile.mock,
		params: &FileSystemMockDeleteFileParams{s1},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.DeleteFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockDeleteFileExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockDeleteFileResults{err}
	return e.mock
}

// DeleteFile implements infrastructure.FileSystem
func (mmDeleteFile *FileSystemMock) DeleteFile(s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(s1)
	}

	mm_params := &FileSystemMockDeleteFileParams{s1}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_got := FileSystemMockDeleteFileParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("FileSystemMock.DeleteFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the FileSystemMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(s1)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to FileSystemMock.DeleteFile. %v", s1)
	return
}

// DeleteFileAfterCounter returns a count of finished FileSystemMock.DeleteFile invocations
func (mmDeleteFile *FileSystemMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of FileSystemMock.DeleteFile invocations
func (mmDeleteFile *FileSystemMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mFileSystemMockDeleteFile) Calls() []*FileSystemMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*FileSystemMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockDeleteFileDone() bool {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.DeleteFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.DeleteFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.DeleteFile with params: %#v", *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.DeleteFile")
	}
}

type mFileSystemMockGetFilesInFolder struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockGetFilesInFolderExpectation
	expectations       []*FileSystemMockGetFilesInFolderExpectation

	callArgs []*FileSystemMockGetFilesInFolderParams
	mutex    sync.RWMutex
}

// FileSystemMockGetFilesInFolderExpectation specifies expectation struct of the FileSystem.GetFilesInFolder
type FileSystemMockGetFilesInFolderExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockGetFilesInFolderParams
	results *FileSystemMockGetFilesInFolderResults
	Counter uint64
}

// FileSystemMockGetFilesInFolderParams contains parameters of the FileSystem.GetFilesInFolder
type FileSystemMockGetFilesInFolderParams struct {
	s1 string
}

// FileSystemMockGetFilesInFolderResults contains results of the FileSystem.GetFilesInFolder
type FileSystemMockGetFilesInFolderResults struct {
	sa1 []string
}

// Expect sets up expected params for FileSystem.GetFilesInFolder
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Expect(s1 string) *mFileSystemMockGetFilesInFolder {
	if mmGetFilesInFolder.mock.funcGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("FileSystemMock.GetFilesInFolder mock is already set by Set")
	}

	if mmGetFilesInFolder.defaultExpectation == nil {
		mmGetFilesInFolder.defaultExpectation = &FileSystemMockGetFilesInFolderExpectation{}
	}

	mmGetFilesInFolder.defaultExpectation.params = &FileSystemMockGetFilesInFolderParams{s1}
	for _, e := range mmGetFilesInFolder.expectations {
		if minimock.Equal(e.params, mmGetFilesInFolder.defaultExpectation.params) {
			mmGetFilesInFolder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesInFolder.defaultExpectation.params)
		}
	}

	return mmGetFilesInFolder
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.GetFilesInFolder
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Inspect(f func(s1 string)) *mFileSystemMockGetFilesInFolder {
	if mmGetFilesInFolder.mock.inspectFuncGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("Inspect function is already set for FileSystemMock.GetFilesInFolder")
	}

	mmGetFilesInFolder.mock.inspectFuncGetFilesInFolder = f

	return mmGetFilesInFolder
}

// Return sets up results that will be returned by FileSystem.GetFilesInFolder
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Return(sa1 []string) *FileSystemMock {
	if mmGetFilesInFolder.mock.funcGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("FileSystemMock.GetFilesInFolder mock is already set by Set")
	}

	if mmGetFilesInFolder.defaultExpectation == nil {
		mmGetFilesInFolder.defaultExpectation = &FileSystemMockGetFilesInFolderExpectation{mock: mmGetFilesInFolder.mock}
	}
	mmGetFilesInFolder.defaultExpectation.results = &FileSystemMockGetFilesInFolderResults{sa1}
	return mmGetFilesInFolder.mock
}

//Set uses given function f to mock the FileSystem.GetFilesInFolder method
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Set(f func(s1 string) (sa1 []string)) *FileSystemMock {
	if mmGetFilesInFolder.defaultExpectation != nil {
		mmGetFilesInFolder.mock.t.Fatalf("Default expectation is already set for the FileSystem.GetFilesInFolder method")
	}

	if len(mmGetFilesInFolder.expectations) > 0 {
		mmGetFilesInFolder.mock.t.Fatalf("Some expectations are already set for the FileSystem.GetFilesInFolder method")
	}

	mmGetFilesInFolder.mock.funcGetFilesInFolder = f
	return mmGetFilesInFolder.mock
}

// When sets expectation for the FileSystem.GetFilesInFolder which will trigger the result defined by the following
// Then helper
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) When(s1 string) *FileSystemMockGetFilesInFolderExpectation {
	if mmGetFilesInFolder.mock.funcGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("FileSystemMock.GetFilesInFolder mock is already set by Set")
	}

	expectation := &FileSystemMockGetFilesInFolderExpectation{
		mock:   mmGetFilesInFolder.mock,
		params: &FileSystemMockGetFilesInFolderParams{s1},
	}
	mmGetFilesInFolder.expectations = append(mmGetFilesInFolder.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.GetFilesInFolder return parameters for the expectation previously defined by the When method
func (e *FileSystemMockGetFilesInFolderExpectation) Then(sa1 []string) *FileSystemMock {
	e.results = &FileSystemMockGetFilesInFolderResults{sa1}
	return e.mock
}

// GetFilesInFolder implements infrastructure.FileSystem
func (mmGetFilesInFolder *FileSystemMock) GetFilesInFolder(s1 string) (sa1 []string) {
	mm_atomic.AddUint64(&mmGetFilesInFolder.beforeGetFilesInFolderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesInFolder.afterGetFilesInFolderCounter, 1)

	if mmGetFilesInFolder.inspectFuncGetFilesInFolder != nil {
		mmGetFilesInFolder.inspectFuncGetFilesInFolder(s1)
	}

	mm_params := &FileSystemMockGetFilesInFolderParams{s1}

	// Record call args
	mmGetFilesInFolder.GetFilesInFolderMock.mutex.Lock()
	mmGetFilesInFolder.GetFilesInFolderMock.callArgs = append(mmGetFilesInFolder.GetFilesInFolderMock.callArgs, mm_params)
	mmGetFilesInFolder.GetFilesInFolderMock.mutex.Unlock()

	for _, e := range mmGetFilesInFolder.GetFilesInFolderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1
		}
	}

	if mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation.params
		mm_got := FileSystemMockGetFilesInFolderParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesInFolder.t.Errorf("FileSystemMock.GetFilesInFolder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesInFolder.t.Fatal("No results are set for the FileSystemMock.GetFilesInFolder")
		}
		return (*mm_results).sa1
	}
	if mmGetFilesInFolder.funcGetFilesInFolder != nil {
		return mmGetFilesInFolder.funcGetFilesInFolder(s1)
	}
	mmGetFilesInFolder.t.Fatalf("Unexpected call to FileSystemMock.GetFilesInFolder. %v", s1)
	return
}

// GetFilesInFolderAfterCounter returns a count of finished FileSystemMock.GetFilesInFolder invocations
func (mmGetFilesInFolder *FileSystemMock) GetFilesInFolderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesInFolder.afterGetFilesInFolderCounter)
}

// GetFilesInFolderBeforeCounter returns a count of FileSystemMock.GetFilesInFolder invocations
func (mmGetFilesInFolder *FileSystemMock) GetFilesInFolderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesInFolder.beforeGetFilesInFolderCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.GetFilesInFolder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Calls() []*FileSystemMockGetFilesInFolderParams {
	mmGetFilesInFolder.mutex.RLock()

	argCopy := make([]*FileSystemMockGetFilesInFolderParams, len(mmGetFilesInFolder.callArgs))
	copy(argCopy, mmGetFilesInFolder.callArgs)

	mmGetFilesInFolder.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesInFolderDone returns true if the count of the GetFilesInFolder invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockGetFilesInFolderDone() bool {
	for _, e := range m.GetFilesInFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesInFolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesInFolder != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFilesInFolderInspect logs each unmet expectation
func (m *FileSystemMock) MinimockGetFilesInFolderInspect() {
	for _, e := range m.GetFilesInFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.GetFilesInFolder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesInFolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		if m.GetFilesInFolderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.GetFilesInFolder")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.GetFilesInFolder with params: %#v", *m.GetFilesInFolderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesInFolder != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.GetFilesInFolder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileSystemMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCopyDataToFileInspect()

		m.MinimockDeleteFileInspect()

		m.MinimockGetFilesInFolderInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileSystemMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileSystemMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCopyDataToFileDone() &&
		m.MinimockDeleteFileDone() &&
		m.MinimockGetFilesInFolderDone()
}
