package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i pb-dropbox-downloader/infrastructure.FileSystem -o ./mocks\file_systemmock.go

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FileSystemMock implements infrastructure.FileSystem
type FileSystemMock struct {
	t minimock.Tester

	funcCopyDataToFile          func(s1 string, r1 io.Reader) (err error)
	inspectFuncCopyDataToFile   func(s1 string, r1 io.Reader)
	afterCopyDataToFileCounter  uint64
	beforeCopyDataToFileCounter uint64
	CopyDataToFileMock          mFileSystemMockCopyDataToFile

	funcDeleteFile          func(s1 string) (err error)
	inspectFuncDeleteFile   func(s1 string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mFileSystemMockDeleteFile

	funcGetFilesInFolder          func(s1 string) (sa1 []string)
	inspectFuncGetFilesInFolder   func(s1 string)
	afterGetFilesInFolderCounter  uint64
	beforeGetFilesInFolderCounter uint64
	GetFilesInFolderMock          mFileSystemMockGetFilesInFolder

	funcReadFile          func(filename string) (ba1 []byte, err error)
	inspectFuncReadFile   func(filename string)
	afterReadFileCounter  uint64
	beforeReadFileCounter uint64
	ReadFileMock          mFileSystemMockReadFile

	funcWriteFile          func(filename string, data []byte) (err error)
	inspectFuncWriteFile   func(filename string, data []byte)
	afterWriteFileCounter  uint64
	beforeWriteFileCounter uint64
	WriteFileMock          mFileSystemMockWriteFile
}

// NewFileSystemMock returns a mock for infrastructure.FileSystem
func NewFileSystemMock(t minimock.Tester) *FileSystemMock {
	m := &FileSystemMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CopyDataToFileMock = mFileSystemMockCopyDataToFile{mock: m}
	m.CopyDataToFileMock.callArgs = []*FileSystemMockCopyDataToFileParams{}

	m.DeleteFileMock = mFileSystemMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*FileSystemMockDeleteFileParams{}

	m.GetFilesInFolderMock = mFileSystemMockGetFilesInFolder{mock: m}
	m.GetFilesInFolderMock.callArgs = []*FileSystemMockGetFilesInFolderParams{}

	m.ReadFileMock = mFileSystemMockReadFile{mock: m}
	m.ReadFileMock.callArgs = []*FileSystemMockReadFileParams{}

	m.WriteFileMock = mFileSystemMockWriteFile{mock: m}
	m.WriteFileMock.callArgs = []*FileSystemMockWriteFileParams{}

	return m
}

type mFileSystemMockCopyDataToFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockCopyDataToFileExpectation
	expectations       []*FileSystemMockCopyDataToFileExpectation

	callArgs []*FileSystemMockCopyDataToFileParams
	mutex    sync.RWMutex
}

// FileSystemMockCopyDataToFileExpectation specifies expectation struct of the FileSystem.CopyDataToFile
type FileSystemMockCopyDataToFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockCopyDataToFileParams
	results *FileSystemMockCopyDataToFileResults
	Counter uint64
}

// FileSystemMockCopyDataToFileParams contains parameters of the FileSystem.CopyDataToFile
type FileSystemMockCopyDataToFileParams struct {
	s1 string
	r1 io.Reader
}

// FileSystemMockCopyDataToFileResults contains results of the FileSystem.CopyDataToFile
type FileSystemMockCopyDataToFileResults struct {
	err error
}

// Expect sets up expected params for FileSystem.CopyDataToFile
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Expect(s1 string, r1 io.Reader) *mFileSystemMockCopyDataToFile {
	if mmCopyDataToFile.mock.funcCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("FileSystemMock.CopyDataToFile mock is already set by Set")
	}

	if mmCopyDataToFile.defaultExpectation == nil {
		mmCopyDataToFile.defaultExpectation = &FileSystemMockCopyDataToFileExpectation{}
	}

	mmCopyDataToFile.defaultExpectation.params = &FileSystemMockCopyDataToFileParams{s1, r1}
	for _, e := range mmCopyDataToFile.expectations {
		if minimock.Equal(e.params, mmCopyDataToFile.defaultExpectation.params) {
			mmCopyDataToFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyDataToFile.defaultExpectation.params)
		}
	}

	return mmCopyDataToFile
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.CopyDataToFile
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Inspect(f func(s1 string, r1 io.Reader)) *mFileSystemMockCopyDataToFile {
	if mmCopyDataToFile.mock.inspectFuncCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("Inspect function is already set for FileSystemMock.CopyDataToFile")
	}

	mmCopyDataToFile.mock.inspectFuncCopyDataToFile = f

	return mmCopyDataToFile
}

// Return sets up results that will be returned by FileSystem.CopyDataToFile
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Return(err error) *FileSystemMock {
	if mmCopyDataToFile.mock.funcCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("FileSystemMock.CopyDataToFile mock is already set by Set")
	}

	if mmCopyDataToFile.defaultExpectation == nil {
		mmCopyDataToFile.defaultExpectation = &FileSystemMockCopyDataToFileExpectation{mock: mmCopyDataToFile.mock}
	}
	mmCopyDataToFile.defaultExpectation.results = &FileSystemMockCopyDataToFileResults{err}
	return mmCopyDataToFile.mock
}

//Set uses given function f to mock the FileSystem.CopyDataToFile method
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Set(f func(s1 string, r1 io.Reader) (err error)) *FileSystemMock {
	if mmCopyDataToFile.defaultExpectation != nil {
		mmCopyDataToFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.CopyDataToFile method")
	}

	if len(mmCopyDataToFile.expectations) > 0 {
		mmCopyDataToFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.CopyDataToFile method")
	}

	mmCopyDataToFile.mock.funcCopyDataToFile = f
	return mmCopyDataToFile.mock
}

// When sets expectation for the FileSystem.CopyDataToFile which will trigger the result defined by the following
// Then helper
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) When(s1 string, r1 io.Reader) *FileSystemMockCopyDataToFileExpectation {
	if mmCopyDataToFile.mock.funcCopyDataToFile != nil {
		mmCopyDataToFile.mock.t.Fatalf("FileSystemMock.CopyDataToFile mock is already set by Set")
	}

	expectation := &FileSystemMockCopyDataToFileExpectation{
		mock:   mmCopyDataToFile.mock,
		params: &FileSystemMockCopyDataToFileParams{s1, r1},
	}
	mmCopyDataToFile.expectations = append(mmCopyDataToFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.CopyDataToFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockCopyDataToFileExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockCopyDataToFileResults{err}
	return e.mock
}

// CopyDataToFile implements infrastructure.FileSystem
func (mmCopyDataToFile *FileSystemMock) CopyDataToFile(s1 string, r1 io.Reader) (err error) {
	mm_atomic.AddUint64(&mmCopyDataToFile.beforeCopyDataToFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyDataToFile.afterCopyDataToFileCounter, 1)

	if mmCopyDataToFile.inspectFuncCopyDataToFile != nil {
		mmCopyDataToFile.inspectFuncCopyDataToFile(s1, r1)
	}

	mm_params := &FileSystemMockCopyDataToFileParams{s1, r1}

	// Record call args
	mmCopyDataToFile.CopyDataToFileMock.mutex.Lock()
	mmCopyDataToFile.CopyDataToFileMock.callArgs = append(mmCopyDataToFile.CopyDataToFileMock.callArgs, mm_params)
	mmCopyDataToFile.CopyDataToFileMock.mutex.Unlock()

	for _, e := range mmCopyDataToFile.CopyDataToFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCopyDataToFile.CopyDataToFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyDataToFile.CopyDataToFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyDataToFile.CopyDataToFileMock.defaultExpectation.params
		mm_got := FileSystemMockCopyDataToFileParams{s1, r1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyDataToFile.t.Errorf("FileSystemMock.CopyDataToFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyDataToFile.CopyDataToFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyDataToFile.t.Fatal("No results are set for the FileSystemMock.CopyDataToFile")
		}
		return (*mm_results).err
	}
	if mmCopyDataToFile.funcCopyDataToFile != nil {
		return mmCopyDataToFile.funcCopyDataToFile(s1, r1)
	}
	mmCopyDataToFile.t.Fatalf("Unexpected call to FileSystemMock.CopyDataToFile. %v %v", s1, r1)
	return
}

// CopyDataToFileAfterCounter returns a count of finished FileSystemMock.CopyDataToFile invocations
func (mmCopyDataToFile *FileSystemMock) CopyDataToFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyDataToFile.afterCopyDataToFileCounter)
}

// CopyDataToFileBeforeCounter returns a count of FileSystemMock.CopyDataToFile invocations
func (mmCopyDataToFile *FileSystemMock) CopyDataToFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyDataToFile.beforeCopyDataToFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.CopyDataToFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyDataToFile *mFileSystemMockCopyDataToFile) Calls() []*FileSystemMockCopyDataToFileParams {
	mmCopyDataToFile.mutex.RLock()

	argCopy := make([]*FileSystemMockCopyDataToFileParams, len(mmCopyDataToFile.callArgs))
	copy(argCopy, mmCopyDataToFile.callArgs)

	mmCopyDataToFile.mutex.RUnlock()

	return argCopy
}

// MinimockCopyDataToFileDone returns true if the count of the CopyDataToFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockCopyDataToFileDone() bool {
	for _, e := range m.CopyDataToFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyDataToFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyDataToFile != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyDataToFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockCopyDataToFileInspect() {
	for _, e := range m.CopyDataToFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.CopyDataToFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyDataToFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		if m.CopyDataToFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.CopyDataToFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.CopyDataToFile with params: %#v", *m.CopyDataToFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyDataToFile != nil && mm_atomic.LoadUint64(&m.afterCopyDataToFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.CopyDataToFile")
	}
}

type mFileSystemMockDeleteFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockDeleteFileExpectation
	expectations       []*FileSystemMockDeleteFileExpectation

	callArgs []*FileSystemMockDeleteFileParams
	mutex    sync.RWMutex
}

// FileSystemMockDeleteFileExpectation specifies expectation struct of the FileSystem.DeleteFile
type FileSystemMockDeleteFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockDeleteFileParams
	results *FileSystemMockDeleteFileResults
	Counter uint64
}

// FileSystemMockDeleteFileParams contains parameters of the FileSystem.DeleteFile
type FileSystemMockDeleteFileParams struct {
	s1 string
}

// FileSystemMockDeleteFileResults contains results of the FileSystem.DeleteFile
type FileSystemMockDeleteFileResults struct {
	err error
}

// Expect sets up expected params for FileSystem.DeleteFile
func (mmDeleteFile *mFileSystemMockDeleteFile) Expect(s1 string) *mFileSystemMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("FileSystemMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &FileSystemMockDeleteFileExpectation{}
	}

	mmDeleteFile.defaultExpectation.params = &FileSystemMockDeleteFileParams{s1}
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.DeleteFile
func (mmDeleteFile *mFileSystemMockDeleteFile) Inspect(f func(s1 string)) *mFileSystemMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for FileSystemMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by FileSystem.DeleteFile
func (mmDeleteFile *mFileSystemMockDeleteFile) Return(err error) *FileSystemMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("FileSystemMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &FileSystemMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &FileSystemMockDeleteFileResults{err}
	return mmDeleteFile.mock
}

//Set uses given function f to mock the FileSystem.DeleteFile method
func (mmDeleteFile *mFileSystemMockDeleteFile) Set(f func(s1 string) (err error)) *FileSystemMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	return mmDeleteFile.mock
}

// When sets expectation for the FileSystem.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mFileSystemMockDeleteFile) When(s1 string) *FileSystemMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("FileSystemMock.DeleteFile mock is already set by Set")
	}

	expectation := &FileSystemMockDeleteFileExpectation{
		mock:   mmDeleteFile.mock,
		params: &FileSystemMockDeleteFileParams{s1},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.DeleteFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockDeleteFileExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockDeleteFileResults{err}
	return e.mock
}

// DeleteFile implements infrastructure.FileSystem
func (mmDeleteFile *FileSystemMock) DeleteFile(s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(s1)
	}

	mm_params := &FileSystemMockDeleteFileParams{s1}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_got := FileSystemMockDeleteFileParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("FileSystemMock.DeleteFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the FileSystemMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(s1)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to FileSystemMock.DeleteFile. %v", s1)
	return
}

// DeleteFileAfterCounter returns a count of finished FileSystemMock.DeleteFile invocations
func (mmDeleteFile *FileSystemMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of FileSystemMock.DeleteFile invocations
func (mmDeleteFile *FileSystemMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mFileSystemMockDeleteFile) Calls() []*FileSystemMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*FileSystemMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockDeleteFileDone() bool {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.DeleteFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.DeleteFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.DeleteFile with params: %#v", *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && mm_atomic.LoadUint64(&m.afterDeleteFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.DeleteFile")
	}
}

type mFileSystemMockGetFilesInFolder struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockGetFilesInFolderExpectation
	expectations       []*FileSystemMockGetFilesInFolderExpectation

	callArgs []*FileSystemMockGetFilesInFolderParams
	mutex    sync.RWMutex
}

// FileSystemMockGetFilesInFolderExpectation specifies expectation struct of the FileSystem.GetFilesInFolder
type FileSystemMockGetFilesInFolderExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockGetFilesInFolderParams
	results *FileSystemMockGetFilesInFolderResults
	Counter uint64
}

// FileSystemMockGetFilesInFolderParams contains parameters of the FileSystem.GetFilesInFolder
type FileSystemMockGetFilesInFolderParams struct {
	s1 string
}

// FileSystemMockGetFilesInFolderResults contains results of the FileSystem.GetFilesInFolder
type FileSystemMockGetFilesInFolderResults struct {
	sa1 []string
}

// Expect sets up expected params for FileSystem.GetFilesInFolder
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Expect(s1 string) *mFileSystemMockGetFilesInFolder {
	if mmGetFilesInFolder.mock.funcGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("FileSystemMock.GetFilesInFolder mock is already set by Set")
	}

	if mmGetFilesInFolder.defaultExpectation == nil {
		mmGetFilesInFolder.defaultExpectation = &FileSystemMockGetFilesInFolderExpectation{}
	}

	mmGetFilesInFolder.defaultExpectation.params = &FileSystemMockGetFilesInFolderParams{s1}
	for _, e := range mmGetFilesInFolder.expectations {
		if minimock.Equal(e.params, mmGetFilesInFolder.defaultExpectation.params) {
			mmGetFilesInFolder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesInFolder.defaultExpectation.params)
		}
	}

	return mmGetFilesInFolder
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.GetFilesInFolder
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Inspect(f func(s1 string)) *mFileSystemMockGetFilesInFolder {
	if mmGetFilesInFolder.mock.inspectFuncGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("Inspect function is already set for FileSystemMock.GetFilesInFolder")
	}

	mmGetFilesInFolder.mock.inspectFuncGetFilesInFolder = f

	return mmGetFilesInFolder
}

// Return sets up results that will be returned by FileSystem.GetFilesInFolder
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Return(sa1 []string) *FileSystemMock {
	if mmGetFilesInFolder.mock.funcGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("FileSystemMock.GetFilesInFolder mock is already set by Set")
	}

	if mmGetFilesInFolder.defaultExpectation == nil {
		mmGetFilesInFolder.defaultExpectation = &FileSystemMockGetFilesInFolderExpectation{mock: mmGetFilesInFolder.mock}
	}
	mmGetFilesInFolder.defaultExpectation.results = &FileSystemMockGetFilesInFolderResults{sa1}
	return mmGetFilesInFolder.mock
}

//Set uses given function f to mock the FileSystem.GetFilesInFolder method
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Set(f func(s1 string) (sa1 []string)) *FileSystemMock {
	if mmGetFilesInFolder.defaultExpectation != nil {
		mmGetFilesInFolder.mock.t.Fatalf("Default expectation is already set for the FileSystem.GetFilesInFolder method")
	}

	if len(mmGetFilesInFolder.expectations) > 0 {
		mmGetFilesInFolder.mock.t.Fatalf("Some expectations are already set for the FileSystem.GetFilesInFolder method")
	}

	mmGetFilesInFolder.mock.funcGetFilesInFolder = f
	return mmGetFilesInFolder.mock
}

// When sets expectation for the FileSystem.GetFilesInFolder which will trigger the result defined by the following
// Then helper
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) When(s1 string) *FileSystemMockGetFilesInFolderExpectation {
	if mmGetFilesInFolder.mock.funcGetFilesInFolder != nil {
		mmGetFilesInFolder.mock.t.Fatalf("FileSystemMock.GetFilesInFolder mock is already set by Set")
	}

	expectation := &FileSystemMockGetFilesInFolderExpectation{
		mock:   mmGetFilesInFolder.mock,
		params: &FileSystemMockGetFilesInFolderParams{s1},
	}
	mmGetFilesInFolder.expectations = append(mmGetFilesInFolder.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.GetFilesInFolder return parameters for the expectation previously defined by the When method
func (e *FileSystemMockGetFilesInFolderExpectation) Then(sa1 []string) *FileSystemMock {
	e.results = &FileSystemMockGetFilesInFolderResults{sa1}
	return e.mock
}

// GetFilesInFolder implements infrastructure.FileSystem
func (mmGetFilesInFolder *FileSystemMock) GetFilesInFolder(s1 string) (sa1 []string) {
	mm_atomic.AddUint64(&mmGetFilesInFolder.beforeGetFilesInFolderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesInFolder.afterGetFilesInFolderCounter, 1)

	if mmGetFilesInFolder.inspectFuncGetFilesInFolder != nil {
		mmGetFilesInFolder.inspectFuncGetFilesInFolder(s1)
	}

	mm_params := &FileSystemMockGetFilesInFolderParams{s1}

	// Record call args
	mmGetFilesInFolder.GetFilesInFolderMock.mutex.Lock()
	mmGetFilesInFolder.GetFilesInFolderMock.callArgs = append(mmGetFilesInFolder.GetFilesInFolderMock.callArgs, mm_params)
	mmGetFilesInFolder.GetFilesInFolderMock.mutex.Unlock()

	for _, e := range mmGetFilesInFolder.GetFilesInFolderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1
		}
	}

	if mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation.params
		mm_got := FileSystemMockGetFilesInFolderParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesInFolder.t.Errorf("FileSystemMock.GetFilesInFolder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesInFolder.GetFilesInFolderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesInFolder.t.Fatal("No results are set for the FileSystemMock.GetFilesInFolder")
		}
		return (*mm_results).sa1
	}
	if mmGetFilesInFolder.funcGetFilesInFolder != nil {
		return mmGetFilesInFolder.funcGetFilesInFolder(s1)
	}
	mmGetFilesInFolder.t.Fatalf("Unexpected call to FileSystemMock.GetFilesInFolder. %v", s1)
	return
}

// GetFilesInFolderAfterCounter returns a count of finished FileSystemMock.GetFilesInFolder invocations
func (mmGetFilesInFolder *FileSystemMock) GetFilesInFolderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesInFolder.afterGetFilesInFolderCounter)
}

// GetFilesInFolderBeforeCounter returns a count of FileSystemMock.GetFilesInFolder invocations
func (mmGetFilesInFolder *FileSystemMock) GetFilesInFolderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesInFolder.beforeGetFilesInFolderCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.GetFilesInFolder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesInFolder *mFileSystemMockGetFilesInFolder) Calls() []*FileSystemMockGetFilesInFolderParams {
	mmGetFilesInFolder.mutex.RLock()

	argCopy := make([]*FileSystemMockGetFilesInFolderParams, len(mmGetFilesInFolder.callArgs))
	copy(argCopy, mmGetFilesInFolder.callArgs)

	mmGetFilesInFolder.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesInFolderDone returns true if the count of the GetFilesInFolder invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockGetFilesInFolderDone() bool {
	for _, e := range m.GetFilesInFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesInFolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesInFolder != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFilesInFolderInspect logs each unmet expectation
func (m *FileSystemMock) MinimockGetFilesInFolderInspect() {
	for _, e := range m.GetFilesInFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.GetFilesInFolder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesInFolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		if m.GetFilesInFolderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.GetFilesInFolder")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.GetFilesInFolder with params: %#v", *m.GetFilesInFolderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesInFolder != nil && mm_atomic.LoadUint64(&m.afterGetFilesInFolderCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.GetFilesInFolder")
	}
}

type mFileSystemMockReadFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockReadFileExpectation
	expectations       []*FileSystemMockReadFileExpectation

	callArgs []*FileSystemMockReadFileParams
	mutex    sync.RWMutex
}

// FileSystemMockReadFileExpectation specifies expectation struct of the FileSystem.ReadFile
type FileSystemMockReadFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockReadFileParams
	results *FileSystemMockReadFileResults
	Counter uint64
}

// FileSystemMockReadFileParams contains parameters of the FileSystem.ReadFile
type FileSystemMockReadFileParams struct {
	filename string
}

// FileSystemMockReadFileResults contains results of the FileSystem.ReadFile
type FileSystemMockReadFileResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for FileSystem.ReadFile
func (mmReadFile *mFileSystemMockReadFile) Expect(filename string) *mFileSystemMockReadFile {
	if mmReadFile.mock.funcReadFile != nil {
		mmReadFile.mock.t.Fatalf("FileSystemMock.ReadFile mock is already set by Set")
	}

	if mmReadFile.defaultExpectation == nil {
		mmReadFile.defaultExpectation = &FileSystemMockReadFileExpectation{}
	}

	mmReadFile.defaultExpectation.params = &FileSystemMockReadFileParams{filename}
	for _, e := range mmReadFile.expectations {
		if minimock.Equal(e.params, mmReadFile.defaultExpectation.params) {
			mmReadFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadFile.defaultExpectation.params)
		}
	}

	return mmReadFile
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.ReadFile
func (mmReadFile *mFileSystemMockReadFile) Inspect(f func(filename string)) *mFileSystemMockReadFile {
	if mmReadFile.mock.inspectFuncReadFile != nil {
		mmReadFile.mock.t.Fatalf("Inspect function is already set for FileSystemMock.ReadFile")
	}

	mmReadFile.mock.inspectFuncReadFile = f

	return mmReadFile
}

// Return sets up results that will be returned by FileSystem.ReadFile
func (mmReadFile *mFileSystemMockReadFile) Return(ba1 []byte, err error) *FileSystemMock {
	if mmReadFile.mock.funcReadFile != nil {
		mmReadFile.mock.t.Fatalf("FileSystemMock.ReadFile mock is already set by Set")
	}

	if mmReadFile.defaultExpectation == nil {
		mmReadFile.defaultExpectation = &FileSystemMockReadFileExpectation{mock: mmReadFile.mock}
	}
	mmReadFile.defaultExpectation.results = &FileSystemMockReadFileResults{ba1, err}
	return mmReadFile.mock
}

//Set uses given function f to mock the FileSystem.ReadFile method
func (mmReadFile *mFileSystemMockReadFile) Set(f func(filename string) (ba1 []byte, err error)) *FileSystemMock {
	if mmReadFile.defaultExpectation != nil {
		mmReadFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.ReadFile method")
	}

	if len(mmReadFile.expectations) > 0 {
		mmReadFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.ReadFile method")
	}

	mmReadFile.mock.funcReadFile = f
	return mmReadFile.mock
}

// When sets expectation for the FileSystem.ReadFile which will trigger the result defined by the following
// Then helper
func (mmReadFile *mFileSystemMockReadFile) When(filename string) *FileSystemMockReadFileExpectation {
	if mmReadFile.mock.funcReadFile != nil {
		mmReadFile.mock.t.Fatalf("FileSystemMock.ReadFile mock is already set by Set")
	}

	expectation := &FileSystemMockReadFileExpectation{
		mock:   mmReadFile.mock,
		params: &FileSystemMockReadFileParams{filename},
	}
	mmReadFile.expectations = append(mmReadFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.ReadFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockReadFileExpectation) Then(ba1 []byte, err error) *FileSystemMock {
	e.results = &FileSystemMockReadFileResults{ba1, err}
	return e.mock
}

// ReadFile implements infrastructure.FileSystem
func (mmReadFile *FileSystemMock) ReadFile(filename string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmReadFile.beforeReadFileCounter, 1)
	defer mm_atomic.AddUint64(&mmReadFile.afterReadFileCounter, 1)

	if mmReadFile.inspectFuncReadFile != nil {
		mmReadFile.inspectFuncReadFile(filename)
	}

	mm_params := &FileSystemMockReadFileParams{filename}

	// Record call args
	mmReadFile.ReadFileMock.mutex.Lock()
	mmReadFile.ReadFileMock.callArgs = append(mmReadFile.ReadFileMock.callArgs, mm_params)
	mmReadFile.ReadFileMock.mutex.Unlock()

	for _, e := range mmReadFile.ReadFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmReadFile.ReadFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadFile.ReadFileMock.defaultExpectation.Counter, 1)
		mm_want := mmReadFile.ReadFileMock.defaultExpectation.params
		mm_got := FileSystemMockReadFileParams{filename}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadFile.t.Errorf("FileSystemMock.ReadFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadFile.ReadFileMock.defaultExpectation.results
		if mm_results == nil {
			mmReadFile.t.Fatal("No results are set for the FileSystemMock.ReadFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmReadFile.funcReadFile != nil {
		return mmReadFile.funcReadFile(filename)
	}
	mmReadFile.t.Fatalf("Unexpected call to FileSystemMock.ReadFile. %v", filename)
	return
}

// ReadFileAfterCounter returns a count of finished FileSystemMock.ReadFile invocations
func (mmReadFile *FileSystemMock) ReadFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFile.afterReadFileCounter)
}

// ReadFileBeforeCounter returns a count of FileSystemMock.ReadFile invocations
func (mmReadFile *FileSystemMock) ReadFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFile.beforeReadFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.ReadFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadFile *mFileSystemMockReadFile) Calls() []*FileSystemMockReadFileParams {
	mmReadFile.mutex.RLock()

	argCopy := make([]*FileSystemMockReadFileParams, len(mmReadFile.callArgs))
	copy(argCopy, mmReadFile.callArgs)

	mmReadFile.mutex.RUnlock()

	return argCopy
}

// MinimockReadFileDone returns true if the count of the ReadFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockReadFileDone() bool {
	for _, e := range m.ReadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadFile != nil && mm_atomic.LoadUint64(&m.afterReadFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockReadFileInspect() {
	for _, e := range m.ReadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.ReadFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadFileCounter) < 1 {
		if m.ReadFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.ReadFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.ReadFile with params: %#v", *m.ReadFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadFile != nil && mm_atomic.LoadUint64(&m.afterReadFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.ReadFile")
	}
}

type mFileSystemMockWriteFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockWriteFileExpectation
	expectations       []*FileSystemMockWriteFileExpectation

	callArgs []*FileSystemMockWriteFileParams
	mutex    sync.RWMutex
}

// FileSystemMockWriteFileExpectation specifies expectation struct of the FileSystem.WriteFile
type FileSystemMockWriteFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockWriteFileParams
	results *FileSystemMockWriteFileResults
	Counter uint64
}

// FileSystemMockWriteFileParams contains parameters of the FileSystem.WriteFile
type FileSystemMockWriteFileParams struct {
	filename string
	data     []byte
}

// FileSystemMockWriteFileResults contains results of the FileSystem.WriteFile
type FileSystemMockWriteFileResults struct {
	err error
}

// Expect sets up expected params for FileSystem.WriteFile
func (mmWriteFile *mFileSystemMockWriteFile) Expect(filename string, data []byte) *mFileSystemMockWriteFile {
	if mmWriteFile.mock.funcWriteFile != nil {
		mmWriteFile.mock.t.Fatalf("FileSystemMock.WriteFile mock is already set by Set")
	}

	if mmWriteFile.defaultExpectation == nil {
		mmWriteFile.defaultExpectation = &FileSystemMockWriteFileExpectation{}
	}

	mmWriteFile.defaultExpectation.params = &FileSystemMockWriteFileParams{filename, data}
	for _, e := range mmWriteFile.expectations {
		if minimock.Equal(e.params, mmWriteFile.defaultExpectation.params) {
			mmWriteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteFile.defaultExpectation.params)
		}
	}

	return mmWriteFile
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.WriteFile
func (mmWriteFile *mFileSystemMockWriteFile) Inspect(f func(filename string, data []byte)) *mFileSystemMockWriteFile {
	if mmWriteFile.mock.inspectFuncWriteFile != nil {
		mmWriteFile.mock.t.Fatalf("Inspect function is already set for FileSystemMock.WriteFile")
	}

	mmWriteFile.mock.inspectFuncWriteFile = f

	return mmWriteFile
}

// Return sets up results that will be returned by FileSystem.WriteFile
func (mmWriteFile *mFileSystemMockWriteFile) Return(err error) *FileSystemMock {
	if mmWriteFile.mock.funcWriteFile != nil {
		mmWriteFile.mock.t.Fatalf("FileSystemMock.WriteFile mock is already set by Set")
	}

	if mmWriteFile.defaultExpectation == nil {
		mmWriteFile.defaultExpectation = &FileSystemMockWriteFileExpectation{mock: mmWriteFile.mock}
	}
	mmWriteFile.defaultExpectation.results = &FileSystemMockWriteFileResults{err}
	return mmWriteFile.mock
}

//Set uses given function f to mock the FileSystem.WriteFile method
func (mmWriteFile *mFileSystemMockWriteFile) Set(f func(filename string, data []byte) (err error)) *FileSystemMock {
	if mmWriteFile.defaultExpectation != nil {
		mmWriteFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.WriteFile method")
	}

	if len(mmWriteFile.expectations) > 0 {
		mmWriteFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.WriteFile method")
	}

	mmWriteFile.mock.funcWriteFile = f
	return mmWriteFile.mock
}

// When sets expectation for the FileSystem.WriteFile which will trigger the result defined by the following
// Then helper
func (mmWriteFile *mFileSystemMockWriteFile) When(filename string, data []byte) *FileSystemMockWriteFileExpectation {
	if mmWriteFile.mock.funcWriteFile != nil {
		mmWriteFile.mock.t.Fatalf("FileSystemMock.WriteFile mock is already set by Set")
	}

	expectation := &FileSystemMockWriteFileExpectation{
		mock:   mmWriteFile.mock,
		params: &FileSystemMockWriteFileParams{filename, data},
	}
	mmWriteFile.expectations = append(mmWriteFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.WriteFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockWriteFileExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockWriteFileResults{err}
	return e.mock
}

// WriteFile implements infrastructure.FileSystem
func (mmWriteFile *FileSystemMock) WriteFile(filename string, data []byte) (err error) {
	mm_atomic.AddUint64(&mmWriteFile.beforeWriteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteFile.afterWriteFileCounter, 1)

	if mmWriteFile.inspectFuncWriteFile != nil {
		mmWriteFile.inspectFuncWriteFile(filename, data)
	}

	mm_params := &FileSystemMockWriteFileParams{filename, data}

	// Record call args
	mmWriteFile.WriteFileMock.mutex.Lock()
	mmWriteFile.WriteFileMock.callArgs = append(mmWriteFile.WriteFileMock.callArgs, mm_params)
	mmWriteFile.WriteFileMock.mutex.Unlock()

	for _, e := range mmWriteFile.WriteFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWriteFile.WriteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteFile.WriteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteFile.WriteFileMock.defaultExpectation.params
		mm_got := FileSystemMockWriteFileParams{filename, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteFile.t.Errorf("FileSystemMock.WriteFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteFile.WriteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteFile.t.Fatal("No results are set for the FileSystemMock.WriteFile")
		}
		return (*mm_results).err
	}
	if mmWriteFile.funcWriteFile != nil {
		return mmWriteFile.funcWriteFile(filename, data)
	}
	mmWriteFile.t.Fatalf("Unexpected call to FileSystemMock.WriteFile. %v %v", filename, data)
	return
}

// WriteFileAfterCounter returns a count of finished FileSystemMock.WriteFile invocations
func (mmWriteFile *FileSystemMock) WriteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteFile.afterWriteFileCounter)
}

// WriteFileBeforeCounter returns a count of FileSystemMock.WriteFile invocations
func (mmWriteFile *FileSystemMock) WriteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteFile.beforeWriteFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.WriteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteFile *mFileSystemMockWriteFile) Calls() []*FileSystemMockWriteFileParams {
	mmWriteFile.mutex.RLock()

	argCopy := make([]*FileSystemMockWriteFileParams, len(mmWriteFile.callArgs))
	copy(argCopy, mmWriteFile.callArgs)

	mmWriteFile.mutex.RUnlock()

	return argCopy
}

// MinimockWriteFileDone returns true if the count of the WriteFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockWriteFileDone() bool {
	for _, e := range m.WriteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteFile != nil && mm_atomic.LoadUint64(&m.afterWriteFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockWriteFileInspect() {
	for _, e := range m.WriteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.WriteFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteFileCounter) < 1 {
		if m.WriteFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.WriteFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.WriteFile with params: %#v", *m.WriteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteFile != nil && mm_atomic.LoadUint64(&m.afterWriteFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.WriteFile")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileSystemMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCopyDataToFileInspect()

		m.MinimockDeleteFileInspect()

		m.MinimockGetFilesInFolderInspect()

		m.MinimockReadFileInspect()

		m.MinimockWriteFileInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileSystemMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileSystemMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCopyDataToFileDone() &&
		m.MinimockDeleteFileDone() &&
		m.MinimockGetFilesInFolderDone() &&
		m.MinimockReadFileDone() &&
		m.MinimockWriteFileDone()
}
